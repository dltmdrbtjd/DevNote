## issue
- 서버쪽에서 set-Cookie방식으로 회원을 검증하기때문에 클라이언트쪽에서는 어떤값을 가지고 핸들링해서 예외처리를 할 방법에 막혀있었다. 왜냐면 set-Cookie방식으로 쿠키를 전달하면 클라이언트에서 접근할 수 있는 방법이 없기때문이다. 그래서 혼자 이것저것 상상해보면서 어떤 방법이 있나 고민하고 팀원들과 얘기하다가 내가 제시한 방법에서 뭔가 돌파구가 생겼던것 같다.

## 내가 혼자 상상한 방법
set-Cookie를 주고 받을때마다 새로운 jwt토큰을 발급한다. 그리고 그 jwt토큰이 있는지 여부로 클라이언트에서는 로그인 여부를 확인하고 서버에서는 set-Cookie가 있는지에 대한 여부로 로그인상태를 확인한다.

서버에서는 set-Cookie가 있으면 다시 새로운 jwt토큰 발급 error 발생시는 클라이언트에서 delete cookie를 하고

=> 결론은 서버에서는 set-Cookie로 로그인확인을 할 수 있고 => 클라이언트는 jwt로 확인하면 결국은 2중 보안이다.

원래 맞는게 로그인 한다.. -> 2.체크할값을 클라이언트에서 저장한다 -> 그다음 로그인체크함수실행 -> 4.리덕스상태변화

매번 새로운 토큰발급. set-cookie ,토큰 -> 우리가 토큰이랑 쿠키를 보내서 확인을하고 성공하면 로그인-> 서버에 요청할때 우리가 가진 토큰,쿠키를 보내고 토큰삭제 , 서버에서 세션값이랑 새로만든 토큰이랑 받은게 같냐 아니냐 확인하고 새토큰을 발행해서 준다.

1.로그인 -> 세션 토큰 발행 -> 토큰 쿠키에 담고 -> 메인 -> 로그아웃(토큰 삭제 및 세션삭제), 세션 만료시 (refresh, 토큰) 보내주고

## shooting
정리도 없이 매우 중구난방이지만 이런식으로 계속 생각해보면서 접근하다가 백엔드 쪽에서 double submit cookie 방식?이 위와 유사한 형태같다며 그 방법으로 해결해나가기로했다. 그렇게되면 이제 프론트에서는 토큰으로 핸들링이 가능해지기 때문에 위와 같은 방식으로 어제 해결했다. 서버에서는 set-cookie로 검증도하고 토큰으로도하는 방식인것 같다. 우리쪽에서는 토큰으로 핸들링이 이제 가능해지는것이고 내가 서버쪽에 대해서 자세히 몰라서 정확하게 작성하지 못해서 아쉽기는 하지만 어떤방식의 흐름으로 해결했는지에 대해서 알게되어서 엄청 좋은 경험이였다. 우리팀 새벽4시까지 고생했다...정말루
