## 오늘 내가 작업한것
- 로그인쪽 팀원들과 해결

## 목록
- 로그인쪽 팀원들과 해결 : 우선 어제 문제가되었던 부분이 로그인이 되고 set-cookie도 받고 까지는 확인이 되었는데 프론트에서 로그인 상태를 확인해주면서 그걸 핸들링하면서 다른 페이지접근을 못하게하고 로그인이 안되면 로그인으로 이동시키는 등의 구현에서 계속 오류가 발생하는 문제가 있었다. 오류는 hooks보다 먼저 함수가 실행되기 때문에 발생하는 오류였는데 어제 다같이 고민하다가 내가 제시한 방법으로 해결점을 찾기 시작했던것 같다. 어제 내가 그냥 혼자 상상했던방식은 정리는 안되어있지만

## 내가 상상한 방법
set-Cookie를 주고 받을때마다 새로운 jwt토큰을 발급한다.
그리고 그 jwt토큰이 있는지 여부로 클라이언트에서는 로그인 여부를 확인하고
서버에서는 set-Cookie가 있는지에 대한 여부로 로그인상태를 확인한다.

서버에서는 set-Cookie가 있으면 다시 새로운 jwt토큰 발급
error 발생시는 클라이언트에서 delete cookie를 하고


=> 결론은 서버에서는 set-Cookie로 로그인확인을 할 수 있고
=> 클라이언트는 jwt로 확인하면
결국은 2중 보안이다.

원래 맞는게
로그인 한다.. -> 2.체크할값을 클라이언트에서 저장한다 -> 그다음 로그인체크함수실행 -> 4.리덕스상태변화

매번 새로운 토큰발급.
set-cookie ,토큰 -> 우리가 토큰이랑 쿠키를 보내서 확인을하고 성공하면 로그인-> 서버에 요청할때 우리가 가진 토큰,쿠키를 보내고 토큰삭제 , 서버에서 세션값이랑 새로만든 토큰이랑 받은게 같냐 아니냐 확인하고 새토큰을 발행해서 준다. 

1.로그인 -> 세션 토큰 발행 -> 토큰 쿠키에 담고 -> 메인 -> 로그아웃(토큰 삭제 및 세션삭제), 세션 만료시 (refresh, 토큰) 보내주고

## 해결핸 방법
- 정리도 없이 매우 중구난방이지만 이런식으로 계속 생각해보면서 접근하다가 백엔드 쪽에서 double submit cookie 방식?이 위와 유사한 형태같다며 그 방법으로 해결해나가기로했다. 그렇게되면 이제 프론트에서는 토큰으로 핸들링이 가능해지기 때문에 위와 같은 방식으로 어제 해결했다. 서버에서는 set-cookie로 검증도하고 토큰으로도하는 방식인것 같다. 우리쪽에서는 토큰으로 핸들링을하고 새벽4시까지... 다들 고생했다 정말 우리팀
